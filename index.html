<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Platformer Game with Iron Man</title>
  <style>
    /* General body and container styles */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #222;
      font-family: Arial, sans-serif;
    }
    /* Score displays positioned at upper left */
    #scoreDisplay {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 20px;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 4px #000;
      z-index: 10;
    }
    #highScoreDisplay {
      position: absolute;
      top: 40px;
      left: 10px;
      font-size: 20px;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 4px #000;
      z-index: 10;
    }
    /* Game container: holds the canvas and the Iron Man element */
    #gameContainer {
      position: relative;
      width: 400px;
      height: 600px;
      margin: 0 auto;
      overflow: hidden;
      border: 2px solid #000;
      background: #87CEEB; /* Your background remains unchanged */
    }
    /* The canvas (for platforms, enemies, etc.) */
    #gameCanvas {
      position: absolute;
      left: 0;
      top: 0;
      z-index: 1;
    }
    /* Iron Man graphic:
       This element represents your player. It uses a background image (ironman.png)
       and is absolutely positioned according to game physics. */
    .ironman {
      position: absolute;
      width: 60px;
      height: 90px;
      background: url("ironman.png") no-repeat center center / cover;
      z-index: 5;
    }
    /* Thanos enemy styling */
    .thanos {
      position: absolute;
      width: 40px;
      height: 60px;
      background: url("thanos.png") no-repeat center center / cover;
      z-index: 4;
    }
    /* Mysterio enemy styling */
    .mysterio {
      position: absolute;
      width: 40px;
      height: 60px;
      background: url("mysterio.png") no-repeat center center / cover;
      z-index: 4;
    }
    /* Jump pop animation for visual feedback */
    @keyframes jumpPop {
      0%   { transform: translateY(0); }
      50%  { transform: translateY(-20px); }
      100% { transform: translateY(0); }
    }
    .ironman.jump {
      animation: jumpPop 0.3s ease-out;
    }
    /* Bullet style for upward shooting */
    .bullet {
      position: absolute;
      width: 6px;
      height: 12px;
      background: yellow;
      z-index: 6;
    }
    @keyframes shootUpAnimation {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-600px); opacity: 0; }
    }
    .shootUp {
      animation: shootUpAnimation 1s linear forwards;
    }
    /* Game Over overlay styling */
    #gameOverOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      color: white;
      text-align: center;
      padding-top: 100px;
      z-index: 100;
    }
    #gameOverOverlay h1 {
      font-size: 50px;
      margin-bottom: 20px;
    }
    #gameOverOverlay button {
      font-size: 20px;
      padding: 10px 20px;
      margin-top: 20px;
      cursor: pointer;
    }
    #gameOverOverlay ol {
      text-align: left;
      display: inline-block;
      margin-top: 20px;
      padding: 0 20px;
    }
    #gameOverOverlay li {
      list-style: decimal;
      font-size: 18px;
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <!-- Score displays -->
  <div id="scoreDisplay">Score: 0</div>
  <div id="highScoreDisplay">High Score: 0</div>
  
  <!-- Game container holds both the canvas and the Iron Man character -->
  <div id="gameContainer">
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <!-- Iron Man element replaces the old red rectangle player -->
    <div id="ironman" class="ironman"></div>
  </div>
  
  <!-- Game Over Overlay -->
  <div id="gameOverOverlay">
    <h1>GAME OVER</h1>
    <div id="finalScoreDisplay"></div>
    <button id="playAgainButton">Play Again</button>
    <h2>Leaderboard</h2>
    <ol id="leaderboardList"></ol>
    <p>Press <strong>Q</strong> to Quit, <strong>R</strong> or <strong>Space</strong> to Restart</p>
  </div>
  
  <script>
    /***********************
     * Initialization
     ***********************/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ironmanEl = document.getElementById('ironman');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const highScoreDisplay = document.getElementById('highScoreDisplay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const finalScoreDisplay = document.getElementById('finalScoreDisplay');
    const leaderboardList = document.getElementById('leaderboardList');
    const playAgainButton = document.getElementById('playAgainButton');
    const gameContainer = document.getElementById('gameContainer');
    
    // Game settings
    const gravity = 0.5;
    const friction = 0.8;
    const baseJump = -10; // Base jump velocity
    let score = 0;
    let highScore = 0;
    
    // Player physics object (not drawn; its data determines positioning)
    let player = {
      x: 180,    // Starting X coordinate
      y: 450,    // Starting Y coordinate
      width: 60, // Match the ironman element width
      height: 90, // Match the ironman element height
      speed: 5,
      velX: 0,
      velY: 0,
      jumping: false
    };
    
    // Track additional data
    let highestPlatformIndex = -1;
    let absoluteHeight = 0;
    let currentPlatform = null;
    let gameOver = false;
    let firstPlatformRemoved = false;
    let thanosElements = []; // Store all Thanos enemy elements
    let mysterioElements = []; // Store all Mysterio enemy elements
    
    // Enemy dimensions for platform enemies
    const enemyWidth = 40; // Updated for characters
    const enemyHeight = 60; // Updated for characters
    
    // Platforms array (each will be drawn on the canvas)
    let platforms = [];
    
    // Create the special starting platform (the first level)
    let firstPlatform = {
      id: -1,
      x: 0,
      y: canvas.height - 10,
      width: canvas.width,
      height: 10,
      absoluteY: canvas.height - 10,
      scored: true, // Marked so no score is added when landing here
      standingTime: 0,
      fallCountdown: Infinity, // Won't fall
      isFalling: false,
      fallSpeed: 0,
      color: '#2E8B57',
      enemy: null,
      isFirstPlatform: true
    };
    platforms.push(firstPlatform);
    
    /***********************
     * Input Handling
     ***********************/
    let keys = [];
    window.addEventListener('keydown', function(e) {
      keys[e.keyCode] = true;
      // Jump on Space (key code 32)
      if (e.keyCode === 32 && !player.jumping) {
        player.jumping = true;
        player.velY = baseJump - Math.abs(player.velX);
        currentPlatform = null;
        // Trigger jump pop animation on the Iron Man element
        if (!ironmanEl.classList.contains('jump')) {
          ironmanEl.classList.add('jump');
          setTimeout(() => {
            ironmanEl.classList.remove('jump');
          }, 300);
        }
      }
      // Shoot upward on "S" (either uppercase or lowercase)
      if (e.key === 's' || e.key === 'S') {
        shootUp();
      }
    });
    window.addEventListener('keyup', function(e) {
      keys[e.keyCode] = false;
    });
    
    // Global keydown for Game Over controls
    document.addEventListener('keydown', function(e) {
      if (gameOver) {
        if (e.key === 'q' || e.key === 'Q') {
          quitGame();
        }
        if (e.key === 'r' || e.key === ' ') {
          location.reload();
        }
      }
    });
    
    /***********************
     * Utility Functions
     ***********************/
    
    // Quit game by replacing body content with a thank-you message.
    function quitGame() {
      document.body.innerHTML =
        "<h1 style='color: white; text-align: center; margin-top: 50vh;'>Thanks for playing!</h1>";
    }
    
    // Returns enemy spawn probability based on score: starts at 5%, increases by 1% per 200 score (max 20%).
    function getEnemyProbability() {
      return Math.min(0.05 + Math.floor(score / 200) * 0.01, 0.20);
    }
    
    // Determine platform fall countdown based on current score.
    function getFallCountdown() {
      const baseTime = 5;
      const minTime = 0.5;
      const firstThreshold = 100;
      const secondThreshold = 150;
      const firstTimeDecrease = 0.5;
      const secondTimeDecrease = 0.1;
      const firstDecreaseCount = Math.floor(score / firstThreshold);
      let newTime = Math.max(baseTime - (firstDecreaseCount * firstTimeDecrease), 1);
      if (newTime <= 1) {
        const secondDecreaseCount = Math.floor((score - (firstThreshold * 8)) / secondThreshold);
        newTime = Math.max(1 - (secondDecreaseCount * secondTimeDecrease), minTime);
      }
      return newTime;
    }
    
    // Create an enemy for a platform (50/50 chance for static vs. moving)
    function createEnemy(platform) {
      let enemyType = Math.random() < 0.5 ? 'Type1' : 'Type2';
      
      if (enemyType === 'Type1') {
        // Create a Thanos element
        const thanosEl = document.createElement('div');
        thanosEl.classList.add('thanos');
        gameContainer.appendChild(thanosEl);
        thanosElements.push(thanosEl);
        
        return {
          type: enemyType,
          x: platform.x + (platform.width / 2) - (enemyWidth / 2),
          y: platform.y - enemyHeight,
          width: enemyWidth,
          height: enemyHeight,
          direction: 1,
          speed: 1,
          element: thanosEl
        };
      } else {
        // Create a Mysterio element for Type2 (moving enemy)
        const mysterioEl = document.createElement('div');
        mysterioEl.classList.add('mysterio');
        gameContainer.appendChild(mysterioEl);
        mysterioElements.push(mysterioEl);
        
        return {
          type: enemyType,
          x: platform.x + (platform.width / 2) - (enemyWidth / 2),
          y: platform.y - enemyHeight,
          width: enemyWidth,
          height: enemyHeight,
          direction: 1,
          speed: 1,
          element: mysterioEl
        };
      }
    }
    
    // Update score when landing on a higher platform (skip first platform)
    function updateScore(platformId) {
      if (platformId > highestPlatformIndex) {
        let platform = platforms.find(p => p.id === platformId);
        if (platform && platform.isFirstPlatform) return;
        const levelsJumped = platformId - highestPlatformIndex;
        const scoreIncrement = levelsJumped * 10;
        const newScore = score + scoreIncrement;
        if (newScore % 100 === 0 && platform) {
          platform.isMilestone = true;
        }
        score = newScore;
        highestPlatformIndex = platformId;
        scoreDisplay.textContent = "Score: " + score;
        if (score > highScore) {
          highScore = score;
          highScoreDisplay.textContent = "High Score: " + highScore;
        }
        if (currentPlatform) {
          currentPlatform.fallCountdown = getFallCountdown();
        }
        flashScoreDisplay();
      }
    }
    
    // Brief flash effect on the score display
    function flashScoreDisplay() {
      scoreDisplay.style.color = "#FFFF00";
      setTimeout(() => {
        scoreDisplay.style.color = "white";
      }, 300);
    }
    
    // Get the current color of a platform based on its state
    function getPlatformColor(platform) {
      if (platform.isFalling) return '#8B4513';
      if (platform === currentPlatform) {
        let timeRatio = platform.standingTime / (platform.fallCountdown * 60);
        if (timeRatio < 0.33) return '#593A0A';
        else if (timeRatio < 0.66) return '#704214';
        else return '#8B4513';
      }
      return platform.isFirstPlatform ? '#2E8B57' : '#593A0A';
    }
    
    // Check if the new platform Y position is valid (sufficient spacing)
    function isValidPlatformPosition(newY, platforms) {
      const minVerticalSpacing = player.height + 10;
      return platforms.every(platform => Math.abs(platform.y - newY) >= minVerticalSpacing);
    }
    
    // Update the leaderboard in localStorage with the final score.
    function updateLeaderboard(finalScore) {
      let leaderboard = JSON.parse(localStorage.getItem("leaderboard") || "[]");
      leaderboard.push(finalScore);
      leaderboard.sort((a, b) => b - a);
      leaderboard = leaderboard.slice(0, 10);
      localStorage.setItem("leaderboard", JSON.stringify(leaderboard));
      return leaderboard;
    }
    
    // Show the Game Over overlay along with the leaderboard.
    function showGameOverOverlay() {
      gameOver = true;
      const leaderboard = updateLeaderboard(score);
      finalScoreDisplay.textContent = "Your Score: " + score;
      leaderboardList.innerHTML = "";
      leaderboard.forEach((s) => {
        let li = document.createElement("li");
        li.textContent = s;
        leaderboardList.appendChild(li);
      });
      gameOverOverlay.style.display = "block";
    }
    
    // Restart game when Play Again is clicked.
    playAgainButton.addEventListener("click", function() {
      location.reload();
    });
    
    // Shoot upward: create a bullet that moves upward from Iron Man's top-center.
    function shootUp() {
      const bullet = document.createElement('div');
      bullet.classList.add('bullet', 'shootUp');
      // Determine Iron Man's position relative to game container.
      const rect = ironmanEl.getBoundingClientRect();
      const containerRect = gameContainer.getBoundingClientRect();
      // Place bullet at top-center of Iron Man.
      const startX = rect.left - containerRect.left + (rect.width / 2) - 3; // Bullet width: 6px
      const startY = rect.top - containerRect.top;
      bullet.style.left = startX + 'px';
      bullet.style.top = startY + 'px';
      gameContainer.appendChild(bullet);
      bullet.addEventListener('animationend', () => {
        bullet.remove();
      });
    }
    
    // Clean up enemy elements when removing a platform
    function cleanupEnemyElements() {
      // Clean up Thanos elements
      thanosElements.forEach(el => {
        if (!platforms.some(p => p.enemy && p.enemy.element === el)) {
          el.remove();
        }
      });
      thanosElements = thanosElements.filter(el => 
        platforms.some(p => p.enemy && p.enemy.element === el)
      );
      
      // Clean up Mysterio elements
      mysterioElements.forEach(el => {
        if (!platforms.some(p => p.enemy && p.enemy.element === el)) {
          el.remove();
        }
      });
      mysterioElements = mysterioElements.filter(el => 
        platforms.some(p => p.enemy && p.enemy.element === el)
      );
    }
    
    /***********************
     * Platform Initialization
     ***********************/
    
    // Create additional platforms (apart from firstPlatform)
    for (let i = 0; i < 10; i++) {
      const platformScore = (i + 1) * 10;
      const milestoneValue = Math.floor(i / 10) * 100 + 100;
      let newY;
      let attempts = 0;
      const maxAttempts = 50;
      do {
        newY = canvas.height - (100 * i) - 50 + (Math.random() * 40 - 20);
        attempts++;
        if (attempts >= maxAttempts) {
          newY = canvas.height - (100 * i) - 50;
          break;
        }
      } while (!isValidPlatformPosition(newY, platforms));
      let platform = {
        id: i,
        x: Math.random() * (canvas.width - 50),
        y: newY,
        width: 100,
        height: 10,
        absoluteY: newY,
        scored: false,
        standingTime: 0,
        fallCountdown: getFallCountdown(),
        isFalling: false,
        fallSpeed: 0,
        color: 'black',
        scoreValue: platformScore,
        isMilestone: (i + 1) % 10 === 0,
        milestoneValue: milestoneValue,
        enemy: null
      };
      if (Math.random() < getEnemyProbability()) {
        platform.enemy = createEnemy(platform);
      }
      platforms.push(platform);
    }
    
    // Recycle a platform that moves off screen
    function recyclePlatform(platform) {
      // Remove old enemy element if exists
      if (platform.enemy && platform.enemy.element) {
        platform.enemy.element.remove();
        
        if (platform.enemy.type === 'Type1') {
          thanosElements = thanosElements.filter(el => el !== platform.enemy.element);
        } else {
          mysterioElements = mysterioElements.filter(el => el !== platform.enemy.element);
        }
      }
      
      let newY;
      let attempts = 0;
      const maxAttempts = 50;
      do {
        newY = -50 - (Math.random() * 40);
        attempts++;
        if (attempts >= maxAttempts) {
          newY = -50;
          break;
        }
      } while (!isValidPlatformPosition(newY, platforms));
      platform.y = newY;
      platform.x = Math.random() * (canvas.width - platform.width);
      platform.absoluteY = platform.absoluteY - canvas.height;
      platform.scored = false;
      platform.standingTime = 0;
      platform.isFalling = false;
      platform.fallSpeed = 0;
      platform.color = 'black';
      let maxId = Math.max(...platforms.map(p => p.id));
      platform.id = maxId + 1;
      platform.scoreValue = (platform.id + 1) * 10;
      platform.isMilestone = (platform.id + 1) % 10 === 0;
      platform.milestoneValue = Math.floor(platform.id / 10) * 100 + 100;
      if (Math.random() < getEnemyProbability()) {
        platform.enemy = createEnemy(platform);
      } else {
        platform.enemy = null;
      }
    }
    
    // Simple AABB collision detection
    function isColliding(obj1, obj2) {
      return (
        obj1.x < obj2.x + obj2.width &&
        obj1.x + obj1.width > obj2.x &&
        obj1.y < obj2.y + obj2.height &&
        obj1.y + obj1.height > obj2.y
      );
    }
    
    /***********************
     * Game Loop
     ***********************/
    let lastTime = 0;
    function updateGame(timestamp) {
      if (gameOver) return;
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      
      // Handle left/right movement from arrow keys
      if (keys[39]) { // Right arrow
        if (player.velX < player.speed) player.velX++;
      }
      if (keys[37]) { // Left arrow
        if (player.velX > -player.speed) player.velX--;
      }
      player.velX *= friction;
      player.velY += gravity;
      player.x += player.velX;
      player.y += player.velY;
      
      // Reset current platform if jumping or moving horizontally
      if (player.jumping || Math.abs(player.velX) > 0.5) {
        currentPlatform = null;
      }
      
      absoluteHeight += player.velY < 0 ? -player.velY : 0;
      
      // Remove the first platform once score reaches 50.
      if (score >= 50 && !firstPlatformRemoved) {
        platforms = platforms.filter(p => !p.isFirstPlatform);
        firstPlatformRemoved = true;
      }
      
      // Screen scroll: if the player is in the top quarter, scroll everything down
      if (player.y < canvas.height / 4) {
        let scrollAmount = Math.abs(player.velY);
        player.y += scrollAmount;
        platforms.forEach(platform => {
          platform.y += scrollAmount;
          platform.absoluteY += scrollAmount;
          if (platform.y > canvas.height) {
            recyclePlatform(platform);
          }
        });
      }
      
      // Update falling platforms
      platforms.forEach(platform => {
        if (platform.isFalling) {
          platform.fallSpeed += 0.1;
          platform.y += platform.fallSpeed;
          platform.absoluteY += platform.fallSpeed;
        }
      });
      
      // Update enemy behavior and positions
      platforms.forEach(platform => {
        if (platform.enemy) {
          platform.enemy.y = platform.y - enemyHeight;
          
          // Update enemy element position
          if (platform.enemy.element) {
            platform.enemy.element.style.left = platform.enemy.x + 'px';
            platform.enemy.element.style.top = platform.enemy.y + 'px';
          }
          
          // Moving behavior for Type2 enemies (Mysterio)
          if (platform.enemy.type === 'Type2') {
            platform.enemy.x += platform.enemy.speed * platform.enemy.direction;
            if (platform.enemy.x <= platform.x || (platform.enemy.x + platform.enemy.width) >= (platform.x + platform.width)) {
              platform.enemy.direction *= -1;
            }
          }
        }
      });
      
      // Constrain player horizontally
      if (player.x >= canvas.width - player.width)
        player.x = canvas.width - player.width;
      else if (player.x <= 0)
        player.x = 0;
      
      // Game over if player falls off screen
      if (player.y > canvas.height) {
        showGameOverOverlay();
        return;
      }
      
      // Platform collision detection
      let onPlatform = false;
      platforms.forEach(platform => {
        if (
          !platform.isFalling &&
          player.x < platform.x + platform.width &&
          player.x + player.width > platform.x &&
          player.y + player.height > platform.y &&
          player.y + player.height < platform.y + platform.height &&
          player.velY >= 0
        ) {
          player.jumping = false;
          player.velY = 0;
          player.y = platform.y - player.height;
          onPlatform = true;
          if (currentPlatform !== platform) {
            if (currentPlatform) currentPlatform.standingTime = 0;
            currentPlatform = platform;
          }
          if (!platform.isFirstPlatform && !platform.scored) {
            updateScore(platform.id);
            platform.scored = true;
          }
          if (Math.abs(player.velX) < 0.5) {
            platform.standingTime++;
            if (platform.standingTime >= platform.fallCountdown * 60) {
              platform.isFalling = true;
              platform.fallSpeed = 0.5;
              currentPlatform = null;
            }
          }
        }
      });
      if (!onPlatform) currentPlatform = null;
      
      // Collision detection with enemies
      platforms.forEach(platform => {
        if (platform.enemy && isColliding(player, platform.enemy)) {
          showGameOverOverlay();
        }
      });
      
      // Clear canvas and redraw platforms
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      platforms.forEach(platform => {
        platform.color = getPlatformColor(platform);
        ctx.fillStyle = platform.color;
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        if (platform.isMilestone) {
          drawScoreBox(platform.x + platform.width / 2 - 15, platform.y - 15, platform.milestoneValue);
        }
        if (platform === currentPlatform && !platform.isFalling) {
          let timeRatio = platform.standingTime / (platform.fallCountdown * 60);
          let countdownWidth = platform.width * (1 - timeRatio);
          ctx.fillStyle = 'green';
          ctx.fillRect(platform.x, platform.y - 5, countdownWidth, 3);
        }
      });
      
      // Update the Iron Man element's position to follow the player.
      ironmanEl.style.left = player.x + "px";
      ironmanEl.style.top  = player.y + "px";
      
      // Clean up any orphaned enemy elements
      cleanupEnemyElements();
      
      // Optionally, redraw score on canvas if needed.
      ctx.fillStyle = 'white';
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + score, 10, 30);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.strokeText("Score: " + score, 10, 30);
      
      requestAnimationFrame(updateGame);
    }
    
    // Draw a small wooden box for milestone score display.
    function drawScoreBox(x, y, scoreValue) {
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(x, y, 30, 20);
      ctx.strokeStyle = '#593A0A';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, 30, 20);
      ctx.beginPath();
      ctx.moveTo(x, y + 7);
      ctx.lineTo(x + 30, y + 7);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y + 14);
      ctx.lineTo(x + 30, y + 14);
      ctx.stroke();
      ctx.fillStyle = 'white';
      ctx.font = "12px Arial";
      ctx.textAlign = "center";
      ctx.fillText(scoreValue, x + 15, y + 14);
      ctx.textAlign = "start";
    }
    
    updateGame(0);
  </script>
</body>
</html>