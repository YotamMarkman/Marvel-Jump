<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Platformer Game with Screen Scroll</title>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; }
    #gameCanvas { background-color: #87CEEB; }
    #scoreDisplay {
      position: absolute;
      top: 10px;
      left: 10px;
      font-family: Arial, sans-serif;
      font-size: 20px;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 4px #000000;
    }
  </style>
</head>
<body>
  <div id="scoreDisplay">Score: 0</div>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');

    // Game settings
    const gravity = 0.5;
    const friction = 0.8;
    const baseJump = -10; // Base jump velocity
    let score = 0;
    
    // Track player's highest platform
    let highestPlatformIndex = -1;
    let absoluteHeight = 0; // Track the absolute height including scrolling
    let currentPlatform = null; // Track which platform player is currently standing on
    let gameOver = false; // To track if the game should stop

    // Define enemy dimensions
    const enemyWidth = 20;
    const enemyHeight = 20;

    // Player
    let player = {
      x: canvas.width / 2,
      y: canvas.height - 150,
      width: 20,
      height: 20,
      speed: 5,
      velX: 0,
      velY: 0,
      jumping: false
    };

    // Platforms
    let platforms = [];

    // Key Listener
    let keys = [];
    window.addEventListener('keydown', function(e) {
      keys[e.keyCode] = true;
      if (e.keyCode === 32 && !player.jumping) { // Space key for jump
        player.jumping = true;
        player.velY = baseJump - Math.abs(player.velX); // Higher jump if running faster
        currentPlatform = null; // No longer on a platform
      }
    });
    window.addEventListener('keyup', function(e) {
      keys[e.keyCode] = false;
    });

    // Function: getEnemyProbability
    // Returns the enemy spawn probability.
    // Starts at 5% and increases by 1% for every 200 points in score, to a maximum of 20%.
    function getEnemyProbability() {
      return Math.min(0.05 + Math.floor(score / 200) * 0.01, 0.20);
    }

    // Get platform fall countdown based on current score
    function getFallCountdown() {
      const baseTime = 5; // Start with 5 seconds
      const minTime = 0.5; // Minimum 0.5 seconds
      const firstThreshold = 100; // First decrease every 100 points
      const secondThreshold = 150; // Second decrease every 150 points
      const firstTimeDecrease = 0.5; // First decrease by 0.5 seconds
      const secondTimeDecrease = 0.1; // Second decrease by 0.1 seconds
      
      // Calculate first phase decreases
      const firstDecreaseCount = Math.floor(score / firstThreshold);
      let newTime = Math.max(baseTime - (firstDecreaseCount * firstTimeDecrease), 1);
      
      // If we've reached 1 second, start the second phase of decreases
      if (newTime <= 1) {
        const secondDecreaseCount = Math.floor((score - (firstThreshold * 8)) / secondThreshold);
        newTime = Math.max(1 - (secondDecreaseCount * secondTimeDecrease), minTime);
      }
      
      return newTime;
    }

    // Create an enemy for a platform with chance determined by score.
    // 50% chance for Type1 (static) and 50% for Type2 (moving).
    function createEnemy(platform) {
      let enemyType = Math.random() < 0.5 ? 'Type1' : 'Type2';
      return {
        type: enemyType,
        // Place enemy roughly in the center of the platform
        x: platform.x + (platform.width / 2) - (enemyWidth / 2),
        y: platform.y - enemyHeight,
        width: enemyWidth,
        height: enemyHeight,
        // Only relevant for Type2: moving enemy
        direction: 1,
        speed: 1
      };
    }

    // Updated updateScore function that accounts for multiple platforms jumped.
    function updateScore(platformId) {
      // Only update score if this is a higher platform than the highest one we've been on.
      if (platformId > highestPlatformIndex) {
        const levelsJumped = platformId - highestPlatformIndex;
        const scoreIncrement = levelsJumped * 10;
        const newScore = score + scoreIncrement;
        
        // Check for milestone (score divisible by 100)
        if (newScore % 100 === 0) {
          platforms.find(p => p.id === platformId).isMilestone = true;
        }
        
        score = newScore;
        highestPlatformIndex = platformId;
        scoreDisplay.textContent = "Score: " + score;
        
        if (currentPlatform) {
          currentPlatform.fallCountdown = getFallCountdown();
        }
        
        flashScoreDisplay();
      }
    }

    // Visual feedback for scoring
    function flashScoreDisplay() {
      scoreDisplay.style.color = "#FFFF00"; // Yellow flash
      setTimeout(() => {
        scoreDisplay.style.color = "white"; // Return to white
      }, 300);
    }

    // Get platform color based on countdown
    function getPlatformColor(platform) {
      if (platform.isFalling) {
        return '#8B4513'; // Brown for falling platform
      }
      
      // Not falling yet, but player is standing on it
      if (platform === currentPlatform) {
        let timeRatio = platform.standingTime / (platform.fallCountdown * 60); // Convert to frames (assuming 60 FPS)
        if (timeRatio < 0.33) {
          return '#593A0A'; // Dark wooden color
        } else if (timeRatio < 0.66) {
          return '#704214'; // Medium wooden color
        } else {
          return '#8B4513'; // Light wooden color
        }
      }
      
      return '#593A0A'; // Default color - dark wooden
    }

    // Function to check if a platform position is valid
    function isValidPlatformPosition(newY, platforms) {
      const minVerticalSpacing = player.height + 10; // Minimum space between platforms
      return platforms.every(platform => {
        return Math.abs(platform.y - newY) >= minVerticalSpacing;
      });
    }

    // Initialize platforms
    for (let i = 0; i < 10; i++) {
      const platformScore = (i + 1) * 10;
      const milestoneValue = Math.floor(i / 10) * 100 + 100;
      
      let newY;
      let attempts = 0;
      const maxAttempts = 50; // Prevent infinite loop
      
      do {
        newY = canvas.height - (100 * i) - 50 + (Math.random() * 40 - 20); // Add some randomness
        attempts++;
        if (attempts >= maxAttempts) {
          newY = canvas.height - (100 * i) - 50;
          break;
        }
      } while (!isValidPlatformPosition(newY, platforms));

      let platform = {
        id: i,
        x: Math.random() * (canvas.width - 50),
        y: newY,
        width: 100,
        height: 10,
        absoluteY: newY,
        scored: false,
        standingTime: 0,
        fallCountdown: getFallCountdown(),
        isFalling: false,
        fallSpeed: 0,
        color: 'black',
        scoreValue: platformScore,
        isMilestone: (i + 1) % 10 === 0,
        milestoneValue: milestoneValue,
        enemy: null  // Will hold enemy object if spawned
      };

      // Add an enemy based on the current enemy probability.
      if (Math.random() < getEnemyProbability()) {
        platform.enemy = createEnemy(platform);
      }
      
      platforms.push(platform);
    }

    // Update the platform recycling code to maintain proper spacing and enemy spawn chance.
    function recyclePlatform(platform) {
      let newY;
      let attempts = 0;
      const maxAttempts = 50;
      
      do {
        newY = -50 - (Math.random() * 40); // Start above the screen
        attempts++;
        if (attempts >= maxAttempts) {
          newY = -50;
          break;
        }
      } while (!isValidPlatformPosition(newY, platforms));

      platform.y = newY;
      platform.x = Math.random() * (canvas.width - platform.width);
      platform.absoluteY = platform.absoluteY - canvas.height;
      platform.scored = false;
      platform.standingTime = 0;
      platform.isFalling = false;
      platform.fallSpeed = 0;
      platform.color = 'black';
      
      let maxId = Math.max(...platforms.map(p => p.id));
      platform.id = maxId + 1;
      platform.scoreValue = (platform.id + 1) * 10;
      platform.isMilestone = (platform.id + 1) % 10 === 0;
      platform.milestoneValue = Math.floor(platform.id / 10) * 100 + 100;
      
      // Reset enemy: use the updated enemy probability when recycling.
      if (Math.random() < getEnemyProbability()) {
        platform.enemy = createEnemy(platform);
      } else {
        platform.enemy = null;
      }
    }

    // Helper: Check if two objects are colliding (AABB collision)
    function isColliding(obj1, obj2) {
      return (
        obj1.x < obj2.x + obj2.width &&
        obj1.x + obj1.width > obj2.x &&
        obj1.y < obj2.y + obj2.height &&
        obj1.y + obj1.height > obj2.y
      );
    }

    let lastTime = 0;
    function updateGame(timestamp) {
      if (gameOver) return; // Stop updating if game over
      
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      
      // Handle key inputs (left/right)
      if (keys[39]) { // right arrow
        if (player.velX < player.speed) {
          player.velX++;
        }
      }         
      if (keys[37]) { // left arrow
        if (player.velX > -player.speed) {
          player.velX--;
        }
      }

      player.velX *= friction;
      player.velY += gravity;
      player.x += player.velX;
      player.y += player.velY;

      // Reset current platform if player is jumping or moving horizontally significantly
      if (player.jumping || Math.abs(player.velX) > 0.5) {
        currentPlatform = null;
      }

      absoluteHeight += player.velY < 0 ? -player.velY : 0;

      // Screen scroll when player moves high up
      if (player.y < canvas.height / 4) {
        let scrollAmount = Math.abs(player.velY);
        player.y += scrollAmount;
        
        platforms.forEach(platform => {
          platform.y += scrollAmount;
          platform.absoluteY += scrollAmount;
          if (platform.y > canvas.height) {
            recyclePlatform(platform);
          }
        });
      }

      // Update falling platforms
      platforms.forEach(platform => {
        if (platform.isFalling) {
          platform.fallSpeed += 0.1;
          platform.y += platform.fallSpeed;
          platform.absoluteY += platform.fallSpeed;
        }
      });

      // Enemy behavior: update movement for platforms with an enemy.
      platforms.forEach(platform => {
        if (platform.enemy) {
          // Sync enemy's vertical position with platform.
          platform.enemy.y = platform.y - enemyHeight;
          if (platform.enemy.type === 'Type2') {
            // Move enemy left/right within platform bounds.
            platform.enemy.x += platform.enemy.speed * platform.enemy.direction;
            // Bounce when hitting the edges of the platform.
            if (platform.enemy.x <= platform.x || (platform.enemy.x + platform.enemy.width) >= (platform.x + platform.width)) {
              platform.enemy.direction *= -1;
            }
          }
        }
      });

      // Collision with canvas edges (horizontal)
      if (player.x >= canvas.width - player.width) {
        player.x = canvas.width - player.width;
      } else if (player.x <= 0) {
        player.x = 0;
      }

      // Collision with bottom (ground)
      if (player.y >= canvas.height - player.height) {
        player.y = canvas.height - player.height;
        player.jumping = false;
        player.velY = 0;
      }

      // Platform collision detection
      let onPlatform = false;
      platforms.forEach(platform => {
        if (
          !platform.isFalling &&
          player.x < platform.x + platform.width &&
          player.x + player.width > platform.x &&
          player.y + player.height > platform.y &&
          player.y + player.height < platform.y + platform.height &&
          player.velY >= 0
        ) {
          player.jumping = false;
          player.velY = 0;
          player.y = platform.y - player.height;
          onPlatform = true;
          
          if (currentPlatform !== platform) {
            if (currentPlatform) {
              currentPlatform.standingTime = 0;
            }
            currentPlatform = platform;
          }
          
          if (!platform.scored) {
            updateScore(platform.id);
            platform.scored = true;
          }
          
          if (Math.abs(player.velX) < 0.5) {
            platform.standingTime++;
            if (platform.standingTime >= platform.fallCountdown * 60) {
              platform.isFalling = true;
              platform.fallSpeed = 0.5;
              currentPlatform = null;
            }
          }
        }
      });
      
      if (!onPlatform) {
        currentPlatform = null;
      }

      // Check for collision with any enemy on any platform
      platforms.forEach(platform => {
        if (platform.enemy && isColliding(player, platform.enemy)) {
          gameOver = true;
          alert("Game Over!");
          document.location.reload();
        }
      });

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw platforms and any enemy on them
      platforms.forEach(platform => {
        platform.color = getPlatformColor(platform);
        ctx.fillStyle = platform.color;
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        
        // Draw milestone box if applicable
        if (platform.isMilestone) {
          drawScoreBox(platform.x + platform.width / 2 - 15, platform.y - 15, platform.milestoneValue);
        }
        
        // Draw countdown indicator when player is on the platform
        if (platform === currentPlatform && !platform.isFalling) {
          let timeRatio = platform.standingTime / (platform.fallCountdown * 60);
          let countdownWidth = platform.width * (1 - timeRatio);
          ctx.fillStyle = 'green';
          ctx.fillRect(platform.x, platform.y - 5, countdownWidth, 3);
        }
        
        // Draw enemy if it exists
        if (platform.enemy) {
          // Choose color based on enemy type: Type1 is static (blue), Type2 is moving (red)
          ctx.fillStyle = platform.enemy.type === 'Type1' ? 'blue' : 'red';
          ctx.fillRect(platform.enemy.x, platform.enemy.y, platform.enemy.width, platform.enemy.height);
        }
      });

      // Draw player
      ctx.fillStyle = 'red';
      ctx.fillRect(player.x, player.y, player.width, player.height);

      // Draw score text
      ctx.fillStyle = 'white';
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + score, 10, 30);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.strokeText("Score: " + score, 10, 30);

      requestAnimationFrame(updateGame);
    }

    // Function to draw a wooden box with score
    function drawScoreBox(x, y, scoreValue) {
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(x, y, 30, 20);
      ctx.strokeStyle = '#593A0A';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, 30, 20);
      
      ctx.beginPath();
      ctx.moveTo(x, y + 7);
      ctx.lineTo(x + 30, y + 7);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y + 14);
      ctx.lineTo(x + 30, y + 14);
      ctx.stroke();
      
      ctx.fillStyle = 'white';
      ctx.font = "12px Arial";
      ctx.textAlign = "center";
      ctx.fillText(scoreValue, x + 15, y + 14);
      ctx.textAlign = "start";
    }

    updateGame(0);
  </script>
</body>
</html>
